{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/fat-thinking-and-economies-of-variety","result":{"data":{"post":{"slug":"/fat-thinking-and-economies-of-variety","title":"Fat Thinking and Economies of Variety","date":"15.06.2022","tags":null,"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Fat Thinking and Economies of Variety\",\n  \"date\": \"2022-06-15T00:00:00.000Z\",\n  \"slug\": \"/fat-thinking-and-economies-of-variety\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ribbonfarm.com/2016/07/28/fat-thinking-and-economies-of-variety\"\n  }, \"https://ribbonfarm.com/2016/07/28/fat-thinking-and-economies-of-variety\")), mdx(\"hr\", null), mdx(\"p\", null, \"Leak-before-failure in the broadest sense, is a way to\\xA0bias an entire system\\xA0towards\\xA0open-ended\\xA0learning in a particular area, while managing the\\xA0risk\\xA0of that failure. It is a type of calibrated, directed chaos-monkeying, that actually sacrifices some leanness for growth learning and insurance purposes. \"), mdx(\"hr\", null), mdx(\"p\", null, \"To get\\xA0killed\\xA0in an open-world learning attempt is to experience an event or event cascade that causes such catastrophic damage that you don\\u2019t have the reserve resources to recover at all.\"), mdx(\"hr\", null), mdx(\"p\", null, \"To\\xA0grow stronger\\xA0in an open-world learning attempt is to scale along some vector uncovered by the failure, like a hydra growing two heads where one has been cut off. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"https://ribbonfarm.com/2016/07/28/fat-thinking-and-economies-of-variety Leak-before-failure in the broadest sense, is a way to bias an…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/fat-thinking-and-economies-of-variety","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}